<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>[da]nilo.dev</title>
		<link>http://nilo.dev/</link>
		<description>Blog Posts</description>
		<copyright>2020</copyright>
		<pubDate>Tue, 21 Apr 2020 02:58:39 GMT</pubDate>
		<lastBuildDate>Tue, 21 Apr 2020 02:58:39 GMT</lastBuildDate>
		<item>
			<title>Criando CI/CD do blog com Wyam, Azure Devops e Github Pages</title>
			<link>http://nilo.dev/post/criando-cicd-do-blog-com-wyam-azure-devops-e-github-pages</link>
			<description>&lt;p&gt;Eu vinha mantendo os inputs do Blog na minha maquina e sem versionamento, mas comecei a usar um outro notebook e pensar em copiar/colar o conteúdo prebuild do blog pra conseguir escrever novos artigos era a motivação que eu precisava para fazer o CI/CD.&lt;/p&gt;</description>
			<enclosure url="http://nilo.dev/images/bg/desert-alone.jpg" length="0" type="image" />
			<guid>http://nilo.dev/post/criando-cicd-do-blog-com-wyam-azure-devops-e-github-pages</guid>
			<pubDate>Fri, 10 Apr 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Eu vinha mantendo os inputs do Blog na minha maquina e sem versionamento, mas comecei a usar um outro notebook e pensar em copiar/colar o conteúdo prebuild do blog pra conseguir escrever novos artigos era a motivação que eu precisava para fazer o CI/CD.&lt;/p&gt;
&lt;p&gt;Neste post vamos abordar a criação de um CI/CD, commitando os inputs do blog em um repositório, criando a trigger de commit no master para popular o conteúdo em outro repositório também do Github. É uma implementação não muito convencional, já que nosso ponto de publicação é um repositório do git.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nilo.dev/post/criando-um-blog-com-wyam-github-pages"&gt;post anterior 1&lt;/a&gt;
&lt;a href="https://nilo.dev/post/emails-personalizados-gmail-google-domains"&gt;post anterior 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apenas para dar contexto, se você chegou até aqui e não está familiariado com o termo CI/CD, de forma bem grosseira, CI trata a compilação, testes e geração do artefato válido do projeto (para o nosso caso há somente a compilação para geração do html) e o CD o deployment (que no nosso caso é o envio dos arquivos compilados para o Github Pages). O assunto é extenso, abordado num &lt;a href="https://www.amazon.com.br/Continuous-Delivery-Deployment-Automation-Addison-Wesley-ebook/dp/B003YMNVC0/"&gt;livro&lt;/a&gt; dedicado para esse assunto e também abordado de forma muito mais didatica em &lt;a href="https://www.redhat.com/pt-br/topics/devops/what-is-ci-cd"&gt;artigos&lt;/a&gt; na internet.&lt;/p&gt;
&lt;h1 id="escolha-do-servico-de-cicd"&gt;Escolha do serviço de CI/CD&lt;/h1&gt;
&lt;p&gt;No passado explorei um pouco as possibilidades de integração para hosting de páginas estáticas e há uma grande variedade de ferramentas e serviços que podem ser utilizadas, então eu tinha uma noção das possibilidades aqui. Os critérios de decisão foram:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serviço de uso gratuito;&lt;/li&gt;
&lt;li&gt;Sem necessidade de hosting para o serviço em si;&lt;/li&gt;
&lt;li&gt;Integração simples e possível via arquivos de configuração alocados no repositório de inputs do projeto;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E de cara pensei em utilizar o AppVeyor.&lt;/p&gt;
&lt;h2 id="appveyor"&gt;AppVeyor&lt;/h2&gt;
&lt;p&gt;O AppVeyor é a primeira opção na lista de ferramentas para &lt;a href="https://wyam.io/docs/deployment/appveyor"&gt;deployment do Wyam&lt;/a&gt; na documentação da propria ferramenta. O AppVeyor no passado me chamou a atenção por disponibilizar CI/CD com build-hosts rodando Windows e de graça - não estendi minha pesquisa sobre serviços de build para projetos Windows nos dias de hoje pois não era o tópico, mas num passado antes da Microsoft entrar nessa briga com VSTS online, ao que eu me lembro esses caras eram os únicos a disponibilizarem um serviço gratuito para builds de projetos Windows.&lt;/p&gt;
&lt;p&gt;A ferramenta possui configuração simples, o script utilizado para build pode ficar no repositório do projeto e o uso é gratuito, mas com um porém: o repositório de git utilizado no build precisa ser público. Bom, isso me trouxe uma sensação de incomodo, pois eu precisaria deixar público meus drafts e backlogs, mas não era um bloqueio para utilizar a ferramenta.&lt;/p&gt;
&lt;p&gt;Outro ponto é o exemplo na documentação do Wyam, que expõe o token utilizado para escrever no repositório no script de build... Isso trás a necessidade de armazenar/obter o token de um local diferente do próprio repositório para evitar o problema de segurança de ter uma chave com permissionamento de escrita aberta no github.&lt;/p&gt;
&lt;p&gt;Com certeza esse problema teria um contorno relativamente fácil como armazenar o token como variável de ambiente nas configurações de build, mas eu queria fazer essa integração da forma mais simples possível e decidi explorar outras ferramentas antes de voltar a olhar para o AppVeyor.&lt;/p&gt;
&lt;h2 id="azure-devops"&gt;Azure Devops&lt;/h2&gt;
&lt;p&gt;Azure Devops, antigamente chamado de VSTS.&lt;/p&gt;
&lt;p&gt;Lembrei que, atualmente ao criar projetos no Github, lá estava aquela mensagem de integração com o &lt;strong&gt;Azure Pipelines&lt;/strong&gt; e, desde que a Microsoft adquiriu o Github, a integração para build deveria ter melhorado bastante - em 2018 não era possível escrever o arquivo de build, somente exportá-lo após passar pela interface com configuração toda visual no VSTS. Parece que as coisas haviam melhorado.&lt;/p&gt;
&lt;p&gt;O Azure Devops me surpreendeu positivamente, a interface está muito mais limpa que era no passado e conseguiu de alguma forma manter o modelo de organização utilizado anteriormente - que diga-se de passagem era um dos únicos pontos positivos de utilizar o VSTS em relação a outras ferramentas, antes do VSTS se tornar o Azure Devops.&lt;/p&gt;
&lt;p&gt;Dei uma pesquisada rápida para ter uma ideia se eu ia ter muito trabalho para fazer tudo que eu precisava e encontrei um artigo parecido com o que eu queria, com a diferença que neste exemplo os arquivos de input e output ficavam no mesmo repositório. Não gosto muito dessa abordagem pois deixa os commits ilegíveis (após um commit do código do blog ou a inserção de um novo arquivo de markdown, o CI/CD faria um novo commit no mesmo repositório, com o código compilado...), mas simplifica a implementação. Para quem quiser consultar o artigo do Matt Cooper, que eu me espelhei para esta implementação, ele está disponível &lt;a href="https://cloudblogs.microsoft.com/opensource/2019/04/05/publishing-github-pages-from-azure-pipelines/"&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Bom, o que era para ser um teste de funcionamento acabou virando o serviço que já está em funcionamento para publicação do Blog - então daqui para frente, vamos falar de como implementar o CI/CD.&lt;/p&gt;
&lt;h1 id="criando-a-pipeline-no-azure-devops"&gt;Criando a pipeline no Azure Devops&lt;/h1&gt;
&lt;p&gt;Antes de iniciar as configurações, precisamos de um novo repositório do github, para armazenar os arquivos de markdown utilizados antes do build do Wyam - lembre que o repositório atual contém os arquivos de output já &amp;quot;compilados&amp;quot;. Não vamos passar por todo o processo de criação do repositório aqui, crie um repositório no github - no meu caso criei o projeto &lt;strong&gt;nilo-dev-inputs&lt;/strong&gt; - clone-o para sua maquina, copie os arquivos da raiz do seu projeto utilizado com o Wyam para a pasta do repositório e envie os arquivos para o repositório.&lt;/p&gt;
&lt;p&gt;Se rolar alguma dúvida sobre como enviar os arquivos... Google. Acaba sendo muito mais produtivo para fixar conteúdo aprendido, pesquisar do que copiar e colar tudo de um tutorial.&lt;/p&gt;
&lt;p&gt;Só tome o cuidado de não enviar arquivos desnecessários para o repositório, o arquivo &lt;strong&gt;.gitignore&lt;/strong&gt; que eu utilizo fica configurado da seguinte forma (e novamente, não sabe o funcionamento do .gitignore? Google it):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Pp]ackages/
[Tt]ools/*
[Oo]utput/
nuget.exe
*.zip
/debug.log
/*.packages.xml
/*.wyam.hash
/*.wyam.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Logo de cara, criei um projeto privado no &lt;a href="https://dev.azure.com/"&gt;Azure Devops&lt;/a&gt; com as configurações padrões. Em &lt;strong&gt;Pipelines&lt;/strong&gt; criei um nova pipeline e linkei minha conta do Github ao Azure Devops. Na próxima tela já estava disponível minha lista de repositórios, selecionei o repositório de inputs do blog e na próxima tela já estava disponível o arquivo &lt;strong&gt;azure-pipelines.yml&lt;/strong&gt; para configuração do build. Adicionei apenas o step de build do Wyam, &lt;strong&gt;Save and run&lt;/strong&gt; e o arquivo azure-pipelines.yml já foi commitado para o repositório no github, assim como a build do projeto iniciou. A execução da Pipeline finalizou com sucesso e, apesar de não gerar um artefato, era somente isso que precisavamos para a parte de CI.&lt;/p&gt;
&lt;p&gt;Eu realmente não me lembro de ter uma experiência tão fluída assim com a Microsoft no passado...&lt;/p&gt;
&lt;p&gt;Com o CI configurado, precisamos configurar o CD.&lt;/p&gt;
&lt;h2 id="criacao-da-chave-de-deployment"&gt;Criação da chave de deployment&lt;/h2&gt;
&lt;p&gt;Como agora temos mais componentes, é interessante ter uma ideia do desenho que queremos como estado final quando terminarmos a configuração (e desculpem os garranchos):
&lt;img src="/images/posts/2020/nilodev-cicd.jpg" class="img-fluid" alt="nilodev-cicd" /&gt;&lt;/p&gt;
&lt;p&gt;O projeto atual no Azure Devops possui acesso somente ao repositório &lt;strong&gt;nilo.dev-inputs&lt;/strong&gt; e precisamos habilitar um acesso com permissão de escrita no repositório &lt;strong&gt;nilo.dev&lt;/strong&gt;. Para isso, vamos criar uma chave de deployment no projeto. Na página do projeto no Github, em Settings, acesse Deploy Keys &amp;gt; Add deploy key:
&lt;img src="/images/posts/2020/github-deploykey.jpg" class="img-fluid" alt="github-deploykey" /&gt;&lt;/p&gt;
&lt;p&gt;Gere uma chave &lt;a href="https://help.github.com/pt/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent"&gt;executando um ssh-keygen&lt;/a&gt; (desde 2018 o Windows possui OpenSSH nativo, não precisa baixar nada se não estiver usando linux), nomeie a chave como &amp;quot;deploy_key&amp;quot;, copie o conteúdo da chave publica (deploy_key.pub) e cole no Github.&lt;/p&gt;
&lt;p&gt;De volta na página do projeto no Azure Devops, em Pipelines &amp;gt; Library &amp;gt; Secure Files &amp;gt; &amp;quot;+ Secure File&amp;quot; e faça o upload da sua chave privada gerada anteriormente - pode deletar a chave de seu computador local após o upload.
&lt;img src="/images/posts/2020/azuredevops-securefile.jpg" class="img-fluid" alt="azuredevops-securefile" /&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Iremos utilizar o nome da chave no script de build, se por acaso mudar o nome dela no Secure Files, lembre-se de alterar o script de build utilizando o novo nome;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Feito isso, iremos alterar a pipeline de build. Poderíamos criar uma pipeline com o release ou segmentar o build em mais de uma pipeline, o que eu acho uma complexidade desnecessária para um projeto tão pequeno. Você não precisa concordar comigo, altere o projeto como preferir.&lt;/p&gt;
&lt;p&gt;Em Pipelines, clique na única pipeline existente, clique em &amp;quot;Edit&amp;quot; e adicione o script abaixo - altere o endereço do repositório no código conforme a necessidade - clique em &amp;quot;Save and run&amp;quot; e veja a magica acontecer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;trigger:
- master

pool:
  vmImage: 'ubuntu-latest'

steps:
- task: DotNetCoreInstaller&amp;#64;0
  displayName: Install .NET Core SDK
  name: install_dotnetcore_sdk
  enabled: true
  inputs:
    packageType: 'sdk'
    version: '2.2.101'

- script: dotnet tool install -g Wyam.Tool
  displayName: Install Wyam

- script: wyam
  displayName: Build Site 

- task: DownloadSecureFile&amp;#64;1
  name: deployKey
  displayName: 'Get the deploy key'
  inputs:
    secureFile: deploy_key

- script: |
    echo Installing deployment key $(deployKey.secureFilePath) ...
    mkdir ~/.ssh &amp;amp;&amp;amp; mv $(deployKey.secureFilePath) ~/.ssh/id_rsa
    chmod 700 ~/.ssh &amp;amp;&amp;amp; chmod 600 ~/.ssh/id_rsa
    ssh-keyscan -t rsa github.com &amp;gt;&amp;gt; ~/.ssh/known_hosts
  displayName: 'Install SSH key '

- script: |
    rm -rf .git
    git clone git&amp;#64;github.com:daniloalsilva/nilo.dev.git --branch=master publish
    cp -R publish/.git output/
    cd output
    git config --local user.name &amp;quot;Azure Pipelines&amp;quot;
    git config --local user.email &amp;quot;azuredevops&amp;#64;microsoft.com&amp;quot;
    git add .
    git commit -m &amp;quot;Publishing GitHub Pages&amp;quot;
    git push origin HEAD:master
  displayName: 'Publish GitHub Pages'
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Um alerta deve aparecer na página seguinte, solicitando o acesso da Pipeline ao arquivo deploy_key que está na Library, este alerta aparece uma única vez;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;E é isso, o Azure Devops já fez seu primeiro deploy e a partir de agora, a cada commit na branch master, o Blog [nilo.dev] será atualizado automáticamente!&lt;/p&gt;
&lt;h2 id="extras"&gt;Extras&lt;/h2&gt;
&lt;p&gt;Para deixar o projeto no Azure Devops mais &amp;quot;limpo&amp;quot;, eu prefiro desativar os itens do projeto que não são utilizados, como Boards, Repos, Test Plans e Artifacts. Basta nas configurações do projeto (UX está horrível pra isso no azure devops e eu tive que pesquisar no Google pra achar o botão... A opção está no canto lateral esquerdo, na página do projeto) e desativar os itens não utilizados.&lt;/p&gt;
&lt;p&gt;E você pode tambêm adicionar uma badge da pipeline no seu repositório do Github ou no seu Blog informando se a ultima build do blog funcionou ou falhou, basta pegar o link da badge nas opções da pipeline:
&lt;img src="/images/posts/2020/azuredevops-badge.jpg" class="img-fluid" alt="azuredevops-badge" /&gt;&lt;/p&gt;
&lt;p&gt;E ativar a visualização de badges se seu projeto for privado:
&lt;img src="/images/posts/2020/azuredevops-badgesettings.jpg" class="img-fluid" alt="azuredevops-badgesettings" /&gt;&lt;/p&gt;
&lt;h2 id="preocupacoes"&gt;Preocupações&lt;/h2&gt;
&lt;p&gt;Ainda não sei se, quando o repositório crescer em quantidade de conteúdo, vai haver perda de performance no push ou erros no build. O Github limita cada repositório individualmente à 100GB e recomenda o uso inferior a 1GB para que haja boa performance.&lt;/p&gt;
&lt;p&gt;Vamos descobrir se/quando chegarmos lá!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Referências:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/download-secure-file?view=azure-devops"&gt;https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/download-secure-file?view=azure-devops&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cloudblogs.microsoft.com/opensource/2019/04/05/publishing-github-pages-from-azure-pipelines/"&gt;https://cloudblogs.microsoft.com/opensource/2019/04/05/publishing-github-pages-from-azure-pipelines/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/58674639/azure-pipelines-status-badge-not-getting-displayed-in-markdown"&gt;https://stackoverflow.com/questions/58674639/azure-pipelines-status-badge-not-getting-displayed-in-markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://help.github.com/pt/github/managing-large-files/what-is-my-disk-quota"&gt;https://help.github.com/pt/github/managing-large-files/what-is-my-disk-quota&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>Emails personalizados com Gmail e Google Domains</title>
			<link>http://nilo.dev/post/emails-personalizados-gmail-google-domains</link>
			<description>&lt;p&gt;Continuando o assunto do &lt;a href="https://nilo.dev/post/criando-um-blog-com-wyam-github-pages"&gt;post anterior&lt;/a&gt;, hora de criar emails para o domínio &lt;strong&gt;nilo.dev&lt;/strong&gt;. Logo após a contratação do domínio, um box no painel de controle do Google já oferece o uso do GSuite, com um período de gratuidade de 14 dias, mas sabemos como isso funciona. Passado este período, R$24.30/mês por conta de email criada - claro que o GSuite possui outros serviços, mas já uso serviços semelhantes em outras plataformas e as premissas de não ter custos neste projeto continuam valendo.&lt;/p&gt;</description>
			<enclosure url="http://nilo.dev/images/bg/desert-alone.jpg" length="0" type="image" />
			<guid>http://nilo.dev/post/emails-personalizados-gmail-google-domains</guid>
			<pubDate>Thu, 02 Apr 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Continuando o assunto do &lt;a href="https://nilo.dev/post/criando-um-blog-com-wyam-github-pages"&gt;post anterior&lt;/a&gt;, hora de criar emails para o domínio &lt;strong&gt;nilo.dev&lt;/strong&gt;. Logo após a contratação do domínio, um box no painel de controle do Google já oferece o uso do GSuite, com um período de gratuidade de 14 dias, mas sabemos como isso funciona. Passado este período, R$24.30/mês por conta de email criada - claro que o GSuite possui outros serviços, mas já uso serviços semelhantes em outras plataformas e as premissas de não ter custos neste projeto continuam valendo.&lt;/p&gt;
&lt;p&gt;Oferta no painel de controle do Google Domains:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/posts/2020/google-gsuite.jpg" class="img-fluid" alt="google-gsuite" /&gt;&lt;/p&gt;
&lt;p&gt;Eu não tenho necessidade de uma conta nova de email então vou apenas utilizar minha conta atual, mas para que o processo funcione é necessário ter uma conta de email criada previamente - e neste caso específicamente uma conta do Gmail. Não passaremos pelos passos de criação da conta aqui.&lt;/p&gt;
&lt;h1 id="configurando-alias-e-encaminhamento-de-emails"&gt;Configurando alias e encaminhamento de emails&lt;/h1&gt;
&lt;p&gt;Com a conta no gmail previamente criada, vamos criar um redirecionamento de emails no painel do Google Domains para esta conta. Após clicar na guia &amp;quot;E-mail&amp;quot;, configure os alias de email que deseja utilizar - no meu caso configurei o endereçco &lt;em&gt;d&amp;#64;nilo.dev&lt;/em&gt; explicitamente e um wildcard &amp;quot;*&amp;quot; para receber qualquer email enviado para contas do domínio &amp;quot;&amp;#64;nilo.dev&amp;quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/posts/2020/google-mail-forward.jpg" class="img-fluid" alt="google-mail-forward" /&gt;&lt;/p&gt;
&lt;p&gt;Com a configuração de encaminhamento de emails, já é possível fazer um teste de recebimento, o teste precisa ser feito de uma segunda caixa postal - testar o funcionamento utilizando para enviar a própria conta que recebe o encaminhamento fará com que a mensagem não seja recebida, conforme a &lt;a href="https://support.google.com/domains/answer/6328726?hl=en"&gt;FAQ do Google Domains&lt;/a&gt;. Enviando um email de outra conta do gmail que não seja a daniloalsilva&amp;#64;gmail.com, para d&amp;#64;nilo.dev foi suficiente para testar o funcionamento.&lt;/p&gt;
&lt;h1 id="habilitando-o-envio-de-emails"&gt;Habilitando o envio de emails&lt;/h1&gt;
&lt;p&gt;Após realizado o teste, é necessário habilitar o endereço de email para envio através do Gmail.&lt;/p&gt;
&lt;p&gt;Não configuramos diretamente os servidores MX do domínio para utilizar o serviço de emails do Google pois ele já possui configuração inicial padrão com os endereços MX de DNS do Google. É possível checar essa informação através das guias DNS &amp;gt; Registros sintéticos &amp;gt; Encaminhamento de e-mail:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/posts/2020/google-mail-dns.jpg" class="img-fluid" alt="google-mail-forward" /&gt;&lt;/p&gt;
&lt;p&gt;Também é possível checar essa informação com um nslookup da sua maquina local:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\&amp;gt;nslookup -q=mx nilo.dev 8.8.8.8
Servidor:  dns.google
Address:  8.8.8.8

Não é resposta autoritativa:
nilo.dev        MX preference = 5, mail exchanger = gmr-smtp-in.l.google.com
nilo.dev        MX preference = 10, mail exchanger = alt1.gmr-smtp-in.l.google.com
nilo.dev        MX preference = 20, mail exchanger = alt2.gmr-smtp-in.l.google.com
nilo.dev        MX preference = 30, mail exchanger = alt3.gmr-smtp-in.l.google.com
nilo.dev        MX preference = 40, mail exchanger = alt4.gmr-smtp-in.l.google.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aqui os passos podem ser ligeiramente diferentes, dependendo das configurações de segurança da conta de email em questão. Tenho habilitado para minha conta a &amp;quot;Verificação em duas etapas&amp;quot; e os passos a seguir descrevem a configuração com essa opção já habilitada. Nas configurações da conta do Google (não do Gmail) já com a verificação em duas etapas habilitada, na guia Segurança, clique em &amp;quot;Senhas de app&amp;quot; e crie uma nova senha - para ter uma identificação de onde a senha é utilizada eu utilizei a opção &amp;quot;Outro (nome personalizado)&amp;quot; em Selecionar app e adicionei o nome d&amp;#64;nilo.dev. Uma senha com 16 caracteres deve ser gerada - anote por enquanto.&lt;/p&gt;
&lt;p&gt;Nas configurações do Gmail, em Contas e Importação &amp;gt; Enviar mensagens como, clique em &amp;quot;Adicionar outro endereço de e-mail&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/posts/2020/google-mail-import0.jpg" class="img-fluid" alt="google-mail-forward" /&gt;&lt;/p&gt;
&lt;p&gt;Neste ponto, adicionamos o alias criado no Google Domains &amp;quot;d&amp;#64;nilo.dev&amp;quot; e em seguida o endereço do gmail e a senha recém gerada para autenticar a conta:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/posts/2020/google-mail-import1.jpg" class="img-fluid" alt="google-mail-forward" /&gt;
&lt;img src="/images/posts/2020/google-mail-import2.jpg" class="img-fluid" alt="google-mail-forward" /&gt;&lt;/p&gt;
&lt;p&gt;Feito isso, um email é enviado para a conta d&amp;#64;nilo.dev e recebido na minha conta do gmail devido ao encaminhamento configurado no Google Domains, com conteúdo semelhante ao abaixo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Você solicitou que d&amp;#64;nilo.dev fosse adicionado à sua conta do Gmail.
Código de confirmação: *********

Antes de enviar e-mails de d&amp;#64;nilo.dev usando sua conta do Gmail
(daniloalsilva&amp;#64;gmail.com), clique no link abaixo para confirmar sua solicitação:
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Se você concluiu esta parte da configuração, significa que não há mais necessidade de armazenar aquela senha gerada para o aplicativo, apague de onde tiver anotado. Se precisar novamente no futuro, uma nova senha pode ser gerada.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;E após a confirmação, o endereço &lt;strong&gt;d&amp;#64;nilo.dev&lt;/strong&gt; já está apto para envio e recebimento com uma conta simples do Gmail e com a economia de R$24,30/mês!&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>Criando um blog com Wyam e Github Pages</title>
			<link>http://nilo.dev/post/criando-um-blog-com-wyam-github-pages</link>
			<description>&lt;p&gt;Este projeto não é nada ambicioso, eu precisava somente de um lugar onde pudesse escrever, que sirva como tracking quando eu ou outra pessoa quiser consultar algum conteúdo disponível aqui. Queria observar se tive algum progresso na parte de desenho e animação que estou estudando e não fazia sentido pra mim fazer isso através de uma rede social.&lt;/p&gt;</description>
			<enclosure url="http://nilo.dev/images/bg/desert-alone.jpg" length="0" type="image" />
			<guid>http://nilo.dev/post/criando-um-blog-com-wyam-github-pages</guid>
			<pubDate>Wed, 01 Apr 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="vamos-ao-primeiro-post-novamente"&gt;Vamos ao primeiro post, novamente.&lt;/h1&gt;
&lt;p&gt;Este projeto não é nada ambicioso, eu precisava somente de um lugar onde pudesse escrever, que sirva como tracking quando eu ou outra pessoa quiser consultar algum conteúdo disponível aqui. Queria observar se tive algum progresso na parte de desenho e animação que estou estudando e não fazia sentido pra mim fazer isso através de uma rede social.&lt;/p&gt;
&lt;p&gt;Fiz algumas tentativas no passado, de uso com outras ferramentas para blogging, mas escrever com &lt;em&gt;markdown&lt;/em&gt; e manter o conteúdo no Github tem se mostrado a melhor experiência.&lt;/p&gt;
&lt;h1 id="escolha-do-wyam-com-github-pages"&gt;Escolha do Wyam com Github Pages&lt;/h1&gt;
&lt;p&gt;As premissas para a escolha de uma ferramenta de blogging eram:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Possibilidade de categorização por tags;&lt;/li&gt;
&lt;li&gt;Facilidade de recuperar o conteúdo e reorganiza-lo para outras plataformas;&lt;/li&gt;
&lt;li&gt;Hosting Free;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dentre as ferramentas possíveis, estavam:&lt;/p&gt;
&lt;h2 id="medium"&gt;Medium&lt;/h2&gt;
&lt;p&gt;O Medium de longe seria a opção mais rápida para iniciar este projeto, basta criar uma conta e começar a popular conteúdo. No entanto, o medium ao meu ver da um suporte muito fraco em relação a categorização - levando em consideração que este projeto vai possuir mais de um tipo de assunto.
Há também a falta de flexibilidade para importação e exportação de conteúdo.&lt;/p&gt;
&lt;p&gt;Fosse o caso de agregar seguidores no meu feed e ter uma regularidade de postagem alta, o Medium até seria uma boa escolha... Não é o meu caso.&lt;/p&gt;
&lt;p&gt;Não foi desta vez Medium.&lt;/p&gt;
&lt;h2 id="notion"&gt;Notion&lt;/h2&gt;
&lt;p&gt;Venho utilizando o Notion para documentações de projetos pessoais e ele vem se provado uma ótima ferramenta. Possui templates para diversos tipos de documentos, suporte a media com copy/paste de imagens e videos no corpo da página e até a criação de tabelas dinâmicas e kanbans.&lt;/p&gt;
&lt;p&gt;Dito isso, o Notion não é uma ferramenta de Blogging. Utilizando uma &lt;a href="https://github.com/kjk/notionapi"&gt;lib não oficial&lt;/a&gt;, até é possível exportar os conteúdos em markdown, que adicionando os headers corretos deixa o conteúdo exportável para o Github Pages tranquilamente, utilizando em conjunto uma ferramenta como o Jekyll ou Wyam.&lt;/p&gt;
&lt;p&gt;Não utilizei o Notion pois ele neste momento iria complicar um deploy que pode ser feito sem ele. O suporte a mídia, para adicionar imagens e videos nos posts iria resolver parte do trabalho manual, mas o arquivo .zip, contendo o conteúdo da página criada gerado durante a exportação ainda necessitaria de algumas correções, como mover a mídia para a pasta correta e corrigir os paths.&lt;/p&gt;
&lt;p&gt;Quem sabe no futuro, com tempo para adaptar as integrações.&lt;/p&gt;
&lt;h2 id="wyam-e-github-pages"&gt;Wyam e Github Pages&lt;/h2&gt;
&lt;p&gt;A abordagem com o Notion utilizaria também o Github Pages, mas preferi abordar a explição aqui.&lt;/p&gt;
&lt;p&gt;O Github Pages, utilizado principalmente para criação de documentação de projetos, traz a possiblidade de hospedar conteúdo estático e, isso é simplesmente perfeito para Blogs.
Claro que dependo do conteúdo e a necessidade de uso de plugins em alguns casos, um Wordpress trás uma abordagem muito mais interessante para criação e manutenção de um Blog, mas nos trás a questão: Qual a real necessidade de utilizar conteúdo dinâmico para um site que pode ser estático? Minha maior premissa era não gastar dinheiro desnecessáriamente, o que descarta a contratação de uma área de hospedagem. Sobra o Medium e... O Github!&lt;/p&gt;
&lt;p&gt;Decidido que o conteúdo seria hospedado no Github, a questão agora seria a escolha da ferramenta para gerar o conteúdo estático, baseado em markdown.&lt;/p&gt;
&lt;p&gt;No passado ja havia criado um outro blog utilizando Wyam que, por minha falta de comprometimento, não foi pra frente. Mas eu já investi algum tempo no passado entendendo a ferramenta, o que tornou o processo de criação desta nova página extremamente rápido.&lt;/p&gt;
&lt;h1 id="registro-do-dominio"&gt;Registro do domínio&lt;/h1&gt;
&lt;p&gt;Decididas as ferramentas, hora de contratar um domínio, o que foi o único custo real investido neste projeto. Me comprometi a não gastar muito tempo escolhendo um nome de domínio pois já tinha gasto tempo demais decidindo que ferramentas utilizar e eu estava chegando no limite onde seria mais interessante simplesmente usar o Medium para simplificar o processo. Escolher um nome para o domínio era sempre um processo demorado e desgastante.&lt;/p&gt;
&lt;p&gt;Considerei utilizar a url padrão do Github Pages, algo do tipo &lt;a href="https://daniloalsilva.github.io/"&gt;https://daniloalsilva.github.io/&lt;/a&gt;, até que houvesse uma justificativa real para gastos, e então lembrei que talvez houvesse algum nome de dominio &lt;em&gt;.dev&lt;/em&gt; interessante e curto ainda disponivel para contratação.&lt;/p&gt;
&lt;p&gt;O Google adquiriu o &lt;a href="https://en.wikipedia.org/wiki/.dev" title="top level domain"&gt;TLD&lt;/a&gt; &lt;em&gt;.dev&lt;/em&gt; e, iniciando em 19 de fevereiro de 2019, passou a comercializar esta extensão para registro de domínios - hoje o dominio tem mais ou menos 1 ano e dois meses sendo comercializado, tempo relativamente curto se comparado com o tempo de vida de outras extensões, o que trás a possibilidade de encontrar nomes de domínio curtos ainda disponíveis para compra. Aliás, se você quer registrar um domínio .dev e ainda não fez, essa é a hora.&lt;/p&gt;
&lt;p&gt;Com algumas pesquisas, achei um nome curto para meu domínio, &amp;quot;nilo.dev&amp;quot; e a justificativa de que ele era curto suficiente para lembrar e me permitiria ter um email d&amp;#64;nilo.dev bastaram.&lt;/p&gt;
&lt;h2 id="configuracao-de-dns"&gt;Configuração de DNS&lt;/h2&gt;
&lt;p&gt;Registrei o domínio utilizando o &lt;a href="https://domains.google/"&gt;Google Domains&lt;/a&gt; e a experiência não poderia ter sido melhor. Interface fluída, configurações apresentadas de forma clara, everything works like a charm.&lt;/p&gt;
&lt;p&gt;Configurar o domínio com o Github Pages é uma tarefa fácil, basta em &amp;quot;Registros de recurso personalizados&amp;quot; apontar as entradas padrão de dns para os ips &lt;em&gt;185.199.108.153, 185.199.109.153, 185.199.110.153, 185.199.111.153&lt;/em&gt; e, a entrada www como cname para o root domain, no meu caso nilo.dev.&lt;/p&gt;
&lt;p&gt;Painel de configuração do Google Domains
&lt;img src="/images/posts/2020/google-dns.jpg" class="img-fluid" alt="google-dns" /&gt;&lt;/p&gt;
&lt;h1 id="criando-o-conteudo-estatico-com-wyam"&gt;Criando o conteúdo estático com Wyam&lt;/h1&gt;
&lt;p&gt;O Wyam é uma ferramenta extremamente simples, tanto referente sua instalação quanto customização para o blog. Os exemplos abaixo foram feitos na minha maquina Windows mas o Wyam foi desenvolvido em dotnetcore 2.1.0, que deve rodar tranquilamente em Linux também com algumas adaptações nos comandos executados. Estou executando eles de uma maquina recém instalada, o que me forçou a instalar o dotnetcore e a IDE.&lt;/p&gt;
&lt;p&gt;Instalando o instalador de pacotes (chocolatey):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instalando o Visual Studio Code&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;choco install vscode -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O vscode é bem opcional dentre os itens abordados aqui, mas foi ele o utilizado durante todo o processo para escrever este post, sendo possível sem instalar nenhum addon visualizar o conteúdo (mídia inclusive) escrito utilizando markdown com code highlighting e um preview side-by-side.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/posts/2020/nilodev-vscode.jpg" class="img-fluid" alt="nilodev-vscode" /&gt;&lt;/p&gt;
&lt;p&gt;Instalando o dotnetcore, versões &amp;quot;lastest&amp;quot; e &amp;quot;2.1.0&amp;quot;, esta última utilizada no Wyam.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;choco install dotnetcore -y
choco install dotnetcore-sdk -y
choco install dotnetcore --version=2.1.0 --sidebyside -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instalando o Wyam&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet tool install -g Wyam.Tool
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E por ultimo, o Cake para automatizar o submit dos posts:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;choco install cake.portable -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Feito isso, já é possível testar o Wyam localmente. Crie uma pasta raiz para o projeto e execute os comandos:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;wyam new --recipe Blog
wyam build --recipe Blog --theme CleanBlog -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com isso, se tudo deu certo uma mensagem semelhante a abaixo será exibida no console e a página http://localhost:5080 vai estar disponível para acesso local:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Preview server listening at http://localhost:5080 and serving from path file:///C:/Users/danil/Projects/new_blog/output
Hit Ctrl-C to exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Os arquivos que devem ser enviados para o Github neste ponto estão na pasta &amp;quot;/project_root/output&amp;quot;.&lt;/p&gt;
&lt;h1 id="enviando-o-conteudo-para-o-github-pages"&gt;Enviando o conteúdo para o Github Pages&lt;/h1&gt;
&lt;p&gt;No Github,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Crie um novo repositório - inicie ele com um README;&lt;/li&gt;
&lt;li&gt;Na aba &amp;quot;settings&amp;quot; na seção &amp;quot;Github Pages&amp;quot;, em &lt;strong&gt;source&lt;/strong&gt; selecione &amp;quot;master branch&amp;quot; e em custom domain adicione o endereço de seu domínio&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="/images/posts/2020/github-pages.jpg" class="img-fluid" alt="github-pages" /&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Devido domínios .dev possuírem utilização restrita a HTTPS, o Github pode demorar um pouco para gerar o certificado com Lets Encrypt, no meu caso demorou uns 5~10 minutos - sim a geração de certificado acontece de forma automatica!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Instale o Git, caso não tenha o mesmo instalado:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;choco install git -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para testar o funcionamento antes de automatizar o processo, eu preferi apenas commitar o output para o repositório e, em seguida testar o funcionamento de forma automática utilizando o Cake e alguns scripts em powershell.&lt;/p&gt;
&lt;p&gt;Clone, cópia e envio dos arquivos para o Github:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;git clone git&amp;#64;github.com:daniloalsilva/nilo.dev.git
cp C:\Users\danil\Projects\new_blog\output\* nilo.dev -recurse -force
git add .
git commit -m 'first commit'
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E com isso a página &lt;a href="https://nilo.dev/"&gt;https://nilo.dev/&lt;/a&gt; passou a funcionar!&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Eu deliberadamente não segui boas práticas com o versionamento de código do input que gera a página, pois isso me daria o trabalho de criar mais um repositório e fazer o CI/CD com a instalação de todas essas ferramentas acima, além da autorização do Github numa plataforma como o Netlify ou AppVeyor. Provávelmente eu faça isso, mas não hoje.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="automatizando-o-build-com-cake"&gt;Automatizando o Build com Cake&lt;/h2&gt;
&lt;p&gt;Para facilitar o build do projeto, é necessário adicionar um arquivo &amp;quot;build.cake&amp;quot; na raiz do projeto, com o seguinte conteúdo:&lt;/p&gt;
&lt;p&gt;build.cake:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;#tool nuget:?package=Wyam
#addin nuget:?package=Cake.Wyam

var target = Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;);

Task(&amp;quot;Build&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true
       });
   });
   
Task(&amp;quot;Preview&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true,
           Preview = true,
           Watch = true
       });        
   });

Task(&amp;quot;Default&amp;quot;)
   .IsDependentOn(&amp;quot;Build&amp;quot;);    
   
RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O script acima é uma adaptação do script de build disponibilizado na &lt;a href="https://wyam.io/docs/deployment/cake"&gt;documentação oficial do Wyam&lt;/a&gt;, com a adição dos atributos utilizados como theme e recipe para o Blog.&lt;/p&gt;
&lt;p&gt;Agora para o build do projeto, basta executarmos o comando &amp;quot;cake&amp;quot; a partir da raiz do projeto.&lt;/p&gt;
&lt;p&gt;Para publicar o conteúdo, eu criei um script que baixa o projeto do github, apaga todo seu conteúdo, copia o output do Wyam para a pasta de publicação e envia o novo conteúdo. Até daria para adicionar esse script no Cake, mas prefiro ter um script a parte para publishing no caso de uma integração futura com CI/CD - e nesse ponto eu já fiquei preguiçoso.&lt;/p&gt;
&lt;p&gt;publish.ps1&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;Param (
    [Parameter(Mandatory=$true)]
    $commitMessage
)

# clone repo
$localFolder = &amp;quot;publish&amp;quot;
$repo = &amp;quot;https://github.com/daniloalsilva/nilo.dev.git&amp;quot;
git clone $repo --branch=master $localFolder

# clean publish folder
ls $localFolder | ? {$_.name -ne '.git'} | % {rm $_.FullName -rec -force}

# copy output itens to publish
Copy-Item &amp;quot;output\*&amp;quot; $localFolder -recurse -force

cd $localFolder
git add .
git commit -m $commitMessage
git push

cd ..
rm $localFolder -rec -force
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depois de tudo isso, rodar os comandos &lt;code&gt;cake; publish.ps1 'commit message';&lt;/code&gt; num console de powershell basta para fazer o build e publicar o conteúdo no github.&lt;/p&gt;
&lt;iframe src="https://giphy.com/embed/YFFPjL7iCNNBppy49S" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen&gt;&lt;/iframe&gt;
&lt;p&gt;Outras configurações como Disqus para comentários e de um email para o domínio ainda podem ser feitas, mas estes itens podem ser discutidos num próximo post ou adicionados nesse post gigante posteriormente.&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;
</content:encoded>
		</item>
	</channel>
</rss>